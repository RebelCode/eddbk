/**
 * A collection of items that uses commit and get pattern.
 *
 * This implementation does not operate on a reference to
 * an item set, but instead generates new sets and commits
 * them.
 */
class FunctionalCollection {
  /**
   * @param {Function} getItems The function used to retrieve the state of the item set.
   * @param {Function} setItems The function used to commit the new state of the item set.
   * @param {Function} keyGetter The function used to get item's key.
   */
  constructor(getItems, setItems, keyGetter) {
    if (!getItems) {
      throw new Error(`Getter must be provided`);
    }
    if (!setItems) {
      throw new Error(`Setter must be provided`);
    }
    if (!keyGetter) {
      throw new Error(`Key getter must be provided`);
    }

    this._itemsGetter = getItems;
    this._itemsSetter = setItems;
    this._keyGetter = keyGetter;
  }

  /**
   * Commits the new state of the items set.
   *
   * @param {Object} The new items set.
   */
  _setItems(items) {
    this._itemsSetter(items);
  }

  /**
   * Retrieves a copy of the items set.
   *
   * @return {Object} The new items set. Key is item ID.
   */
  _getItems() {
    return this._itemsGetter();
  }

  /**
   * Retrieves items of the collection.
   *
   * @return {Object} The items, by item ID.
   */
  getItems() {
    return Object.assign({}, this._getItems());
  }

  /**
   * Adds items to the collection.
   *
   * @param {Object} item The item to add
   */
  addItem(item) {
    let items = this._getItems();
    items = this._addItem(items, item);
    this._setItems(items);
  }

  /**
   * Check that given item in the collection.
   *
   * @param item
   * @returns {boolean}
   */
  hasItem(item) {
    return !!this._getItems()[this._keyGetter(item)];
  }

  /**
   * Remove item from set
   *
   * @param {Object} item
   */
  removeItem(item) {
    let items = this._getItems();
    items = this._removeItem(items, item);
    this._setItems(items);
  }

  /**
   * Adds an item to a set.
   *
   * @param {Object} The item set.
   * @param {Object} The item to add.
   *
   * @return {Object} The modified items set.
   */
  _addItem(items, item) {
    items = Object.assign({}, items);
    let id = this._keyGetter(item);
    if (items[id]) {
      throw new Error(`Item with id ${id} already exists`);
    }

    items[id] = item;

    return items;
  }

  /**
   * Remove item from set
   *
   * @param items
   * @param item
   * @returns {*}
   * @private
   */
  _removeItem(items, item) {
    items = Object.assign({}, items);
    delete items[this._keyGetter(item)];
    return items;
  }

  /**
   * Adds multiple items to an item set.
   *
   * @param {Object} items The item set.
   * @param {Array} newItems The items to add.
   *
   * @return {Object} The modified item set.
   */
  _addItems(items, newItems) {
    for (var i in newItems) {
      this._addItem(items, newItems[i]);
    }

    return items;
  }
}

/**
 * Functional collection that works with arrays under the hood
 */
class FunctionalArrayCollection extends FunctionalCollection {
  /**
   * Retrieves items of the collection.
   *
   * @return {Array} The items, by item ID.
   */
  getItems() {
    return this._getItems().slice();
  }

  /**
   * Check that given item in the collection.
   *
   * @param item
   * @returns {boolean}
   */
  hasItem(item) {
    let foundItemIndex = null;
    let items = this._getItems();
    let itemKey = this._keyGetter(item);

    for (let i in items) {
      if (this._keyGetter(items[i]) === itemKey) {
        foundItemIndex = i;
        break;
      }
    }

    return foundItemIndex !== null;
  }

  /**
   * Adds an item to a set.
   *
   * @param {Array} items The item set.
   * @param {Object} item The item to add.
   *
   * @return {Object} The modified items set.
   */
  _addItem(items, item) {
    items = items.slice();
    items.push(item);
    return items;
  }

  /**
   * Remove item from set
   *
   * @param items
   * @param item
   * @returns {*}
   * @private
   */
  _removeItem(items, item) {
    let foundItemIndex = null;
    let itemKey = this._keyGetter(item);
    for (let i in items) {
      if (this._keyGetter(items[i]) == itemKey) {
        foundItemIndex = i;
        break;
      }
    }
    if (foundItemIndex !== null) {
      items.splice(foundItemIndex, 1);
    }
    return items;
  }
}

/**
 * Throw Error if add new item to collection and collection
 * hold too many items.
 *
 * @since [*next-version*]
 *
 * @type {string}
 */
const FLC_OVERFLOW_THROW = 'throw';

/**
 * Start adding item to the collection from start if
 * there are to many items in the collection.
 *
 * @since [*next-version*]
 *
 * @type {string}
 */
const FLC_OVERFLOW_PREPEND = 'prepend';

/**
 * Functional limited collection that works with arrays under the hood
 * and can hold maximal amount of items.
 *
 * @since [*next-version*]
 */
class FunctionalLimitedCollection extends FunctionalArrayCollection {
  /**
   * Constructor.
   *
   * @since [*next-version*]
   *
   * @param {Function} getItems The function used to retrieve the state of the item set.
   * @param {Function} setItems The function used to commit the new state of the item set.
   * @param {Function} keyGetter The function used to get item's key.
   * @param {Number} limit Count of maximal items count in collection.
   * @param {String} overflowMode Define how to deal with items overflow.
   */
  constructor(getItems, setItems, keyGetter, limit, overflowMode) {
    if (!limit) {
      throw new Error(`Collection limit must be provided`);
    }

    if (!overflowMode) {
      throw new Error(`Overflow mode for collection must be provided`);
    }

    super(getItems, setItems, keyGetter);

    /*
     * Check right overflow mode is provided
     */
    if (this._getAllowedOverflowModes().indexOf(overflowMode) === -1) {
      throw new Error(`Wrong overflow mode is provided`);
    }

    this._limit = limit;
    this._overflowMode = overflowMode;

    this._checkOverflow();
  }

  /**
   * Get list of allowed overflow modes.
   *
   * @since [*next-version*]
   *
   * @return {Array} Array of allowed overflow modes
   * @private
   */
  _getAllowedOverflowModes() {
    return [FLC_OVERFLOW_THROW, FLC_OVERFLOW_PREPEND];
  }

  /**
   * Adds an item to a set.
   *
   * @since [*next-version*]
   *
   * @param {Array} items The item set.
   * @param {Object} item The item to add.
   *
   * @return {Array} The modified items set.
   */
  _addItem(items, item) {
    if (items.length + 1 > this._limit) {
      switch (this._overflowMode) {
        case FLC_OVERFLOW_THROW:
          throw new Error(`Limited collection can hold not more that ${this._limit} items`);
          break;
        case FLC_OVERFLOW_PREPEND:
          return this._addItemToStart(items, item);
          break;
      }
    }

    items = items.slice();
    items.push(item);
    return items;
  }

  /**
   * Add item to collection's start, filling whole collection
   * like a circle.
   *
   * @since [*next-version*]
   *
   * @param {Array} items The item set.
   * @param {Object} item The item to add.
   *
   * @return {Array} New item set with added items.
   * @private
   */
  _addItemToStart(items, item) {
    if (this._lastAddedIndex === undefined || this._lastAddedIndex == items.length - 1) {
      this._lastAddedIndex = -1;
    }

    this._lastAddedIndex++;

    items = items.slice();
    items[this._lastAddedIndex] = item;
    return items;
  }

  /**
   * Check collection is not overflowed when created.
   *
   * @since [*next-version*]
   *
   * @private
   */
  _checkOverflow() {
    let items = this._getItems();

    if (items.length <= this._limit) return;

    switch (this._overflowMode) {
      case FLC_OVERFLOW_THROW:
        throw new Error(`Limited collection can hold not more that ${this._limit} items`);
        break;
      case FLC_OVERFLOW_PREPEND:
        this._setItems(items.slice(this._limit));
        break;
    }
  }
}

/**
 * Restricted collection.
 *
 * This collection add ability to check is
 * item allowed to be added to the collection.
 *
 * Uses consumer's function for checking.
 *
 * @since [*next-version*]
 */
class FunctionalRestrictedCollection extends FunctionalArrayCollection {
  /**
   * Constructor.
   *
   * @since [*next-version*]
   *
   * @param {Function} getItems The function used to retrieve the state of the item set.
   * @param {Function} setItems The function used to commit the new state of the item set.
   * @param {Function} keyGetter The function used to get item's key.
   * @param {Function} itemAllowed Function that determines item allowed or not.
   */
  constructor(getItems, setItems, keyGetter, itemAllowed) {
    if (!itemAllowed) {
      throw new Error(`Item allowed checker must be provided`);
    }

    super(getItems, setItems, keyGetter);

    this._itemAllowed = itemAllowed;
  }

  /**
   * If item can be added to the collection
   *
   * @since [*next-version*]
   *
   * @param {object} item Item to be checked is allowed or not.
   * @return {Boolean} Is item allowed to be added to the collection.
   */
  isAllowed(item) {
    return this._itemAllowed(this.getItems(), item);
  }
}

/**
 * Toggleable class for encapsulate "on/off" switching
 * logic. For example, for toggling pages visibility.
 *
 * @since [*next-version*]
 */
class FunctionalToggleable {
  constructor(set, get) {
    this._stateSetter = set;
    this._stateGetter = get;
  }

  /**
   * Set On state.
   *
   * @since [*next-version*]
   *
   * @param isOn
   * @private
   */
  _setState(isOn) {
    this._stateSetter(!!isOn);
  }

  /**
   * Get On state.
   *
   * @since [*next-version*]
   *
   * @returns {*}
   * @private
   */
  _getState() {
    return this._stateGetter();
  }

  /**
   * Get On state.
   *
   * @since [*next-version*]
   *
   * @returns {boolean}
   */
  isOn() {
    let state = this._getState();
    return !!state;
  }

  /**
   * Set current on state.
   *
   * @since [*next-version*]
   *
   * @param isOn
   */
  setState(isOn) {
    this._setState(!!isOn);
  }
}

/**
 * Page. Used for handling templates.
 *
 * @since [*next-version*]
 */
class Page {
  /**
   * Page constructor.
   *
   * @since [*next-version*]
   *
   * @param {string} id Page id.
   * @param {string} template Page template.
   */
  constructor(id, template) {
    this.id = id;
    this.template = template;
  }

  /**
   * Render page.
   *
   * @since [*next-version*]
   *
   * @param {object} ctx Context for rendering page
   * @return {string} Rendered page
   */
  render(ctx) {
    return this.template;
  }
}

/**
 * Api abstraction to make interactions with backend using
 * some http client.
 *
 * @since [*next-version*]
 *
 * @class Api
 */
class Api {
  /**
   * Api constructor
   *
   * @since [*next-version*]
   *
   * @param {HttpClient} httpClient Http promise-based client
   * @param {Object<string, {method: String, endpoint: String}>} config
   * @param {RequestCache} cache Requests caching implementation.
   */
  constructor(httpClient, config, cache) {
    this.http = httpClient;
    this.config = config;
    this.cache = cache;
  }

  /**
   * Prepare params before submit.
   *
   * @since [*next-version*]
   *
   * @param {object} params Params that will be send to Api.
   *
   * @return {object} Prepared params.
   */
  prepareParams(params) {
    return params;
  }
}

/**
 * Request cache, allows to cache request results and use it without sending
 * new requests.
 *
 * @since [*next-version*]
 */
class RequestCache {
  /**
   * Request cache constructor.
   *
   * @since [*next-version*]
   *
   * @param {Function} hashCode Function for getting hash code from object.
   */
  constructor(hashCode) {
    this.hashCode = hashCode;
    this._cache = {};
  }

  /**
   * Remember result in cache. If it is already in cache - return it.
   *
   * @since [*next-version*]
   *
   * @param {object} params Params to retrieve from cache by.
   * @param {Function} request Request promise to remember result from.
   *
   * @return {Promise<any>}
   */
  remember(params, request) {
    if (this.has(params)) {
      return new Promise(resolve => {
        resolve(this.get(params));
      });
    }
    return request().then(data => {
      this.set(params, data);
      return data;
    });
  }

  /**
   * Store data in cache.
   *
   * @since [*next-version*]
   *
   * @param {object} params Params to retrieve from cache by.
   *
   * @param {*} data
   */
  set(params, data) {
    this._cache[this._getCacheKey(params)] = data;
  }

  /**
   * Check cache has item.
   *
   * @since [*next-version*]
   *
   * @param {object} params Params to retrieve from cache by.
   *
   * @return {boolean}
   */
  has(params) {
    return !!this._cache[this._getCacheKey(params)];
  }

  /**
   * Get item from cache by params.
   *
   * @since [*next-version*]
   *
   * @param {object} params Params to retrieve from cache by.
   *
   * @return {*}
   */
  get(params) {
    return this._cache[this._getCacheKey(params)];
  }

  /**
   * Get cache key from params.
   *
   * @since [*next-version*]
   *
   * @param {*} params Key that should be casted to string.
   *
   * @return {string}
   */
  _getCacheKey(params) {
    let orderedParams = {};
    Object.keys(params).sort().map(key => {
      orderedParams[key] = params[key];
    });
    return this.hashCode(JSON.stringify(orderedParams));
  }
}

/**
 * Class for changing object in some way using list of rules
 * that applied to given object in order.
 *
 * @since [*next-version*]
 *
 * @class Transformer
 */
class Transformer {
  constructor() {
    /**
     * List of rules to transform.
     *
     * @since [*next-version*]
     *
     * @type {Object.<string, TransformerRuleCallback>}
     */
    this.rules = {};
  }

  /**
   * Transform given model according rules.
   *
   * @since [*next-version*]
   *
   * @param {object} model Some model to transform
   * @param {object} payload Additional data to use while transformation
   *
   * @return {object} Transformed model
   */
  transform(model, payload = {}) {
    for (let sourceField of Object.keys(this.rules)) {
      const handler = this.rules[sourceField];
      if (!model.hasOwnProperty(sourceField)) {
        continue;
      }
      model = Object.assign({}, model);
      model = handler(model, payload);
    }
    return model;
  }
}

/**
 * Create `createInTimezone` function.
 *
 * @param {moment} moment Moment JS object.
 *
 * @return {CreateInTimezoneFunction} `CreateInTimezone` function.
 */
function makeCreateInTimezone(moment) {
  return (value, tz) => {
    const momentFixedTimezoneValue = moment.parseZone(value);
    if (tz.indexOf('UTC') !== 0) {
      return moment.tz(momentFixedTimezoneValue, tz);
    }
    let offset = Number(tz.replace(/UTC\+?/g, ''));
    return momentFixedTimezoneValue.utcOffset(offset);
  };
}

/**
 * Create `parseInTimezone` function.
 *
 * @param {moment} moment Moment JS object.
 * @param {string} timezoneFreeFormat Datetime format, free from timezone information.
 *
 * @return {ParseInTimezoneFunction} `parseInTimezone` function.
 */
function makeParseInTimezone(moment, timezoneFreeFormat) {
  return (value, tz) => {
    const momentFixedTimezoneValue = moment.parseZone(value);
    if (tz.indexOf('UTC') !== 0) {
      return moment.tz(momentFixedTimezoneValue.format(timezoneFreeFormat), timezoneFreeFormat, tz);
    }
    let offset = Number(tz.replace(/UTC\+?/g, ''));
    return momentFixedTimezoneValue.utcOffset(offset, true);
  };
}

export { FunctionalCollection, FunctionalArrayCollection, FunctionalLimitedCollection, FLC_OVERFLOW_THROW, FLC_OVERFLOW_PREPEND, FunctionalRestrictedCollection, FunctionalToggleable, Page, Api, RequestCache, Transformer, makeCreateInTimezone, makeParseInTimezone };
